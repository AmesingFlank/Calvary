#include "ReinforcementLearningPathTracing.h"
#include "../Samplers/SimpleSampler.h"
#include "../Utils/TaskQueue.h"
#include "../Core/Impl.h"
#include "../Utils/Timer.h"
#include "../Utils/Utils.h"

namespace ReinforcementLearningPathTracing {

#define Q_TABLE_SIZE 64

    using QDistribution = FixedSizeDistribution1D<QEntry::NUM_XY>;

    RLPTIntegrator::RLPTIntegrator(int maxDepth_):maxDepth(maxDepth_),QTable(Q_TABLE_SIZE*Q_TABLE_SIZE*Q_TABLE_SIZE,false) {

    }

    struct QEntryInfo {
        int entryIndex = -1;
        int cellIndex = -1;
    };

    __device__
    int findQEntry(const AABB& sceneBounds, float3 position){
        float3 sceneSize = sceneBounds.maximum-sceneBounds.minimum;
        float3 entrySize = sceneSize / make_float3(Q_TABLE_SIZE,Q_TABLE_SIZE,Q_TABLE_SIZE);
        int3 entryIndex;
        position -= sceneBounds.minimum;
        entryIndex.x = clampF((int)(position.x / entrySize.x),0,Q_TABLE_SIZE-1);
        entryIndex.y = clampF((int)(position.y / entrySize.y),0,Q_TABLE_SIZE-1);
        entryIndex.z = clampF((int)(position.z / entrySize.z),0,Q_TABLE_SIZE-1);
        return entryIndex.x * Q_TABLE_SIZE * Q_TABLE_SIZE + entryIndex.y * Q_TABLE_SIZE + entryIndex.z;
    }

    struct RayTask {
        Ray ray;
        Spectrum multiplier;
        Spectrum* result;
        float materialPDF; // if the ray is generated by sampling a BSDF, this is the PDF of that sample. This is needed for MIS
        bool sampledFromDeltaBSDF;
        QEntryInfo previousQEntry;
    };

    struct LightingTask {
        IntersectionResult intersection;
        Ray thisRay;
        Spectrum multiplier;
        Spectrum* result;
        float materialPDF;
        bool sampledFromDeltaBSDF;
        QEntryInfo previousQEntry;
    };

    struct MaterialEvalTask {
        IntersectionResult intersection;
        Ray rayToLight;
        Spectrum incident;
        Ray exitantRay;
        Spectrum multiplier;
        Spectrum* result;
        float lightPDF;
        QEntryInfo previousQEntry;
    };

    __device__
    inline float misPowerHeuristic(float pdfA, float pdfB) {
        pdfA *= pdfA;
        pdfB *= pdfB;
        return pdfA / (pdfA + pdfB);
    }

    
    // use q entry index as part of the key for sorting. this improves locality.
    __global__
    void writeIndicesAndKeys(int N, LightingTask* tasks, int* indices, int* keys,AABB sceneBounds) {
        int index = blockIdx.x * blockDim.x + threadIdx.x;
        if (index >= N) {
            return;
        }
        
        indices[index] = index;
        int materialID = static_cast<int>(tasks[index].intersection.primitive->material.getType());
        int entryIndex = findQEntry(sceneBounds, tasks[index].intersection.position);

        int key = Q_TABLE_SIZE * Q_TABLE_SIZE * Q_TABLE_SIZE * materialID + entryIndex;
        keys[index] = key;
    }

    __global__
    void applySortedIndices(int N,int* sortedIndices, LightingTask* lightTasks, LightingTask* lightTasksCopy, RayTask* rayTasks, RayTask* rayTasksCopy) {
        int index = blockIdx.x * blockDim.x + threadIdx.x;
        if (index >= N) {
            return;
        }
        lightTasksCopy[index] = lightTasks[sortedIndices[index]];
        rayTasksCopy[index] = rayTasks[sortedIndices[index]];
        
    }

    // sort the lighting queue using material as key.
    // in addition to lighting tasks, we also sort the sampler states and nextRay tasks, so that the low-descrepancy properties of the sampler isn't ruined.
    void sortLightingQueue(TaskQueue<LightingTask>& lightQueue, TaskQueue<LightingTask>& lightQueueCopy, TaskQueue<RayTask>& rayQueue, TaskQueue<RayTask>& rayQueueCopy, SamplerObject& sampler,AABB sceneBounds) {
        int N = lightQueue.count();
        if (N == 0) return;

        lightQueueCopy.setCount(N);

        GpuArray<int> indices(N);
        GpuArray<int> keys(N);

        int numBlocks, numThreads;
        setNumBlocksThreads(N, numBlocks, numThreads);

        writeIndicesAndKeys << <numBlocks, numThreads >> > (N, lightQueue.tasks.data, indices.data, keys.data,sceneBounds);
        CHECK_CUDA_ERROR("write indices and keys");

        thrust::stable_sort_by_key(thrust::device, keys.data, keys.data+N, indices.data);

        applySortedIndices << <numBlocks, numThreads >> > (N,indices.data, lightQueue.tasks.data, lightQueueCopy.tasks.data, rayQueue.tasks.data, rayQueueCopy.tasks.data);
        CHECK_CUDA_ERROR("apply sort");
        std::swap(lightQueue.tasks.data, lightQueueCopy.tasks.data);
        std::swap(rayQueue.tasks.data, rayQueueCopy.tasks.data);

        sampler.reorderStates(indices);


    }


    __global__
    void intersectScene( SceneHandle scene, SamplerObject sampler, TaskQueue<LightingTask> lightingQueue,TaskQueue<RayTask> thisRoundRayQueue, TaskQueue<RayTask> nextRoundRayQueue,int depth) {
        int raysCount = thisRoundRayQueue.count();
        int index = blockIdx.x * blockDim.x + threadIdx.x;
        if (index >= raysCount) {
            return;
        }

        RayTask& myTask = thisRoundRayQueue.tasks.data[index];
        Spectrum* result = myTask.result;
        Spectrum multiplier = myTask.multiplier;
        Ray thisRay = myTask.ray;
        

        IntersectionResult intersection;
        scene.intersect(intersection, thisRay);

        if (!intersection.intersected) {
            if (scene.hasEnvironmentMap()) {
                *result += scene.getEnvironmentMap()->EnvironmentMap::evaluateRay(thisRay) * multiplier;
            }
            return;
        }
        
        LightingTask lightingTask = { intersection,thisRay,multiplier,result,myTask.materialPDF, myTask.sampledFromDeltaBSDF,myTask.previousQEntry };
        lightingQueue.push(lightingTask);
        
    }

    __device__
    void buildQDistribution(QDistribution& dist, QEntry& entry) {

    }

    __global__
    void genNextRay(SceneHandle scene, SamplerObject sampler, TaskQueue<LightingTask> tasks, TaskQueue<RayTask> nextRoundRayQueue, int depth, AABB sceneBounds, GpuArray<QEntry> QTable) {
        int tasksCount = tasks.count();
        int index = blockIdx.x * blockDim.x + threadIdx.x;
        if (index >= tasksCount) {
            return;
        }

        LightingTask& myTask = tasks.tasks.data[index];
        IntersectionResult intersection = myTask.intersection;
        Spectrum* result = myTask.result;
        Ray thisRay = myTask.thisRay;
        Spectrum multiplier = myTask.multiplier;

        //russian roulette
        if (depth > 3) {
            float terminationProbability = 1;
            terminationProbability = min(terminationProbability, 1 - multiplier.x);
            terminationProbability = min(terminationProbability, 1 - multiplier.y);
            terminationProbability = min(terminationProbability, 1 - multiplier.z);

            terminationProbability = max(terminationProbability, 0.05f);

            if (sampler.rand1() < terminationProbability) {
                return;
            }
            multiplier = multiplier / (1.f - terminationProbability);
        }

        const Primitive* prim = intersection.primitive;         

        Ray nextRay;
        float nextRayProbability;

        float3 tangent0, tangent1;
        intersection.findTangents(tangent0, tangent1);

        float3 exitantDir = thisRay.direction * -1.f;

        QEntryInfo entryInfo;
        entryInfo.entryIndex = findQEntry(sceneBounds, intersection.position);

        Spectrum nextMultiplier;

        if (intersection.bsdf.isDelta()) {
            float3 nextDirectionLocal;
            nextMultiplier = intersection.bsdf.sample(sampler.rand2(), nextDirectionLocal, intersection.worldToLocal(exitantDir,tangent0,tangent1), &nextRayProbability);
            nextRay.direction = intersection.localToWorld(nextDirectionLocal);
            nextRay.origin = intersection.position + nextRay.direction * 0.0001f;
            entryInfo.cellIndex = QEntry::dirToCellIndex(nextRay.direction);
        }
        else {
            
            QEntry& entry = QTable.data[entryInfo.entryIndex];
            QDistribution dist;

            float valueSum = 0;
            for (int cellIndex = 0; cellIndex < QEntry::NUM_XY; ++cellIndex) {
                int thetaIdx = cellIndex / QEntry::NUM_X;
                int phiIdx = cellIndex % QEntry::NUM_X;
                float u = ((float)thetaIdx + 0.5f) / QEntry::NUM_Y;
                u = u * 2 - 1.f;
                float v = ((float)phiIdx + 0.5f) / QEntry::NUM_X;

                float xyScale = sqrt(1.0f - u * u);
                float phi = 2 * M_PI * v;
                float3 dir = make_float3(
                    xyScale * cos(phi),
                    xyScale * sin(phi),
                    u);
                float3 exitantLocal = intersection.worldToLocal(exitantDir, tangent0, tangent1);
                float3 incidentLocal = intersection.worldToLocal(dir, tangent0, tangent1);

                Spectrum scattering = intersection.bsdf.eval(incidentLocal, exitantLocal);
                float value = luminance(scattering) * entry.Q[cellIndex] * abs(dot(dir, intersection.normal));
                dist.cdf[cellIndex] = value; // temprarily use cdf array to store the value. saves memory
                valueSum += value;
            }
            float accumulated = 0;
            for (int cellIndex = 0; cellIndex < QEntry::NUM_XY; ++cellIndex) {
                accumulated += dist.cdf[cellIndex] / valueSum;
                dist.cdf[cellIndex] = accumulated;
            }
            entryInfo.cellIndex = dist.sample(sampler.rand1(), nextRayProbability);
            nextRayProbability = (QEntry::NUM_XY * nextRayProbability / (4 * M_PI)); // Solid angle probability


            nextRay.direction = entry.sampleDirectionProportionalToQ(sampler, entryInfo.cellIndex, intersection.normal, exitantDir);
            nextRay.origin = intersection.position + nextRay.direction * 0.0001f;

            nextMultiplier = intersection.bsdf.eval(intersection.worldToLocal(nextRay.direction, tangent0, tangent1), intersection.worldToLocal(exitantDir, tangent0, tangent1));
        }

        if (isAllZero(nextMultiplier)) {
            multiplier = make_float3(0, 0, 0);
        }
        else {
            multiplier = multiplier * nextMultiplier * abs(dot(nextRay.direction, intersection.normal)) / nextRayProbability;
        }

        RayTask nextTask = { nextRay,multiplier,result,nextRayProbability, intersection.bsdf.isDelta(),entryInfo };
        nextRoundRayQueue.push(nextTask);
    }


    __global__
    void computeLighting(SceneHandle scene, SamplerObject sampler, TaskQueue<LightingTask> tasks,TaskQueue<MaterialEvalTask> materialEvalQueue,int depth,AABB sceneBounds,GpuArray<QEntry> QTable) {
        int tasksCount = tasks.count();
        int index = blockIdx.x * blockDim.x + threadIdx.x;
        if (index >= tasksCount) {
            return;
        }

        LightingTask& myTask = tasks.tasks.data[index];
        IntersectionResult intersection = myTask.intersection;
        Spectrum* result = myTask.result;
        Ray thisRay = myTask.thisRay;
        Spectrum multiplier = myTask.multiplier;
        QEntryInfo& previousQEntry = myTask.previousQEntry;

        const Primitive* prim = intersection.primitive;

        if (prim->areaLight) {
            if (myTask.sampledFromDeltaBSDF) {
                // then don't apply MIS, because the sampleRayToPoint call had a 0 probability of finding any radiance;
                *result += prim->areaLight->get<DiffuseAreaLight>()->DiffuseAreaLight::evaluateRay(thisRay,intersection) * multiplier;
            }
            else {
                if (depth > 0 && false) {
                    float materialPDF = myTask.materialPDF;
                    float lightPDF = prim->areaLight->get<DiffuseAreaLight>()->DiffuseAreaLight::sampleRayToPointPdf(thisRay, intersection);
                    float misWeight = misPowerHeuristic(materialPDF, lightPDF);
                    if (isfinite(misWeight)) {
                        *result += prim->areaLight->get<DiffuseAreaLight>()->DiffuseAreaLight::evaluateRay(thisRay, intersection) * multiplier * misWeight;
                    }
                }
            }
        }

        Ray exitantRay = { intersection.position,thisRay.direction * -1 };

        int lightIndex = sampler.randInt(scene.lightsCount);

        const LightObject& light = scene.lights[lightIndex];
        Ray rayToLight;
        float probability;
        float4 randomSource = sampler.rand4();

        VisibilityTest visibilityTest;
        visibilityTest.sourceMeshIndex = intersection.primitive->shape.meshIndex;

        Spectrum incident = light.sampleRayToPoint(intersection.position, sampler, probability, rayToLight, visibilityTest,nullptr);

        if (scene.testVisibility(visibilityTest) && isfinite(probability)) {
            Spectrum materialEvalMultiplier = scene.lightsCount * multiplier / probability;
            materialEvalQueue.push({intersection,rayToLight,incident,exitantRay,materialEvalMultiplier,result,probability,myTask.previousQEntry});
            
            int thisQEntryIndex = findQEntry(sceneBounds, intersection.position);
            QEntry& thisEntry = QTable.data[thisQEntryIndex];
            int cellIndex = QEntry::dirToCellIndex(rayToLight.direction);
            //thisEntry.proposeNextQ(luminance(incident)*scene.lightsCount / probability, cellIndex);
        }
    }

    __global__
    void evalMaterial(SceneHandle scene,TaskQueue<MaterialEvalTask> tasks, AABB sceneBounds,GpuArray<QEntry> QTable) {
        int tasksCount = tasks.count();
        int index = blockIdx.x * blockDim.x + threadIdx.x;
        if (index >= tasksCount) {
            return;
        }

        MaterialEvalTask& myTask = tasks.tasks.data[index];
        IntersectionResult& intersection = myTask.intersection;
        Spectrum* result = myTask.result;
        Spectrum& multiplier = myTask.multiplier;
        Spectrum& incident = myTask.incident;
        QEntryInfo previousQEntry = myTask.previousQEntry;

        Ray& rayToLight = myTask.rayToLight;
        Ray& exitantRay = myTask.exitantRay;

        float lightPDF = myTask.lightPDF;
        float materialPDF = intersection.bsdf.pdf(rayToLight.direction, exitantRay.direction);
        float misWeight = misPowerHeuristic(lightPDF, materialPDF);

        Spectrum scattered = intersection.primitive->material.eval(rayToLight, incident, exitantRay, intersection);
        
        *result += scattered * multiplier * misWeight;

        if (previousQEntry.entryIndex != -1) {
            Spectrum newQ = scattered * scene.lightsCount / myTask.lightPDF;
            int thisQEntryIndex = findQEntry(sceneBounds, intersection.position);
            QEntry& thisEntry = QTable.data[thisQEntryIndex];

            float3 tangent0, tangent1;
            intersection.findTangents(tangent0, tangent1);

            for (int cellIndex = 0; cellIndex < QEntry::NUM_XY; ++cellIndex) {
                int thetaIdx = cellIndex / QEntry::NUM_X;
                int phiIdx = cellIndex % QEntry::NUM_X;
                float u = ((float)thetaIdx + 0.5f) / QEntry::NUM_Y;
                u = u * 2 - 1.f;
                float v = ((float)phiIdx + 0.5f) / QEntry::NUM_X;

                float xyScale = sqrt(1.0f - u * u);
                float phi = 2 * M_PI * v;
                float3 dir = make_float3(
                    xyScale * cos(phi),
                    xyScale * sin(phi),
                    u);
                float3 exitantLocal = intersection.worldToLocal(exitantRay.direction, tangent0, tangent1);
                float3 incidentLocal = intersection.worldToLocal(dir, tangent0, tangent1);

                Spectrum scattering = intersection.bsdf.eval(incidentLocal, exitantLocal);
                Spectrum thisDirQ = (2.f * M_PI / (float)QEntry::NUM_XY) * abs(dot(dir, intersection.normal)) * scattering * thisEntry.Q[cellIndex];
                newQ += thisDirQ;
            }
            QTable.data[previousQEntry.entryIndex].proposeNextQ(luminance(newQ), previousQEntry.cellIndex);
        }
    }


    __global__
    void genInitialRays(CameraSample* samples, int samplesCount, CameraObject camera, Spectrum* results, TaskQueue<RayTask> rayQueue,SamplerObject sampler) {
        int index = blockIdx.x * blockDim.x + threadIdx.x;
        if (index >= samplesCount) {
            return;
        }

        Ray ray = camera.genRay(samples[index]);
        Spectrum* result = &results[index];
        *result = make_float3(0, 0, 0);
        Spectrum multiplier = make_float3(1, 1, 1);
        QEntryInfo nullEntry = { -1,-1};
        RayTask task = { ray,multiplier,result,true,1,nullEntry };
        rayQueue.push(task);
        sampler.startPixel();
    }

     


    __global__
    void addSamplesToFilm(FilmObject film, Spectrum* result, CameraSample* samples, int count) {
        int index = blockIdx.x * blockDim.x + threadIdx.x;
        if (index >= count) {
            return;
        }
        film.addSample(samples[index], result[index]);
    }


    __global__
    void initialiseQTable(GpuArray<QEntry> QTable){
        int index = blockIdx.x * blockDim.x + threadIdx.x;
        if (index >= QTable.N) {
            return;
        }
        QTable.data[index] = QEntry();
    }

    __global__
    void prepareForUpdateQ(GpuArray<QEntry> QTable){
        int index = blockIdx.x * blockDim.x + threadIdx.x;
        if (index >= QTable.N*QEntry::NUM_XY) {
            return;
        }
        int entryIndex = index / QEntry::NUM_XY;
        int cellIndex = index % QEntry::NUM_XY;
        QTable.data[entryIndex].prepareForUpdateQ(cellIndex);
    }

    __global__
    void finishUpdateQ(GpuArray<QEntry> QTable){
        int index = blockIdx.x * blockDim.x + threadIdx.x;
        if (index >= QTable.N*QEntry::NUM_XY) {
            return;
        }
        int entryIndex = index / QEntry::NUM_XY;
        int cellIndex = index % QEntry::NUM_XY;
        QTable.data[entryIndex].finishUpdateQ(cellIndex);
    }


    void debugPrintQTable(const GpuArray<QEntry>& QTable) {
        int size = Q_TABLE_SIZE * Q_TABLE_SIZE * Q_TABLE_SIZE;
        std::vector<QEntry> table = QTable.toVector();
        for (int i = 0; i <size; ++i) {
            QEntry entry = QTable.get(i);
            std::cout << "Entry: " << i << std::endl;
            for (int y = 0; y < QEntry::NUM_Y; y++){
                std::cout << "y=" << y << "   ";
                for (int x = 0; x < QEntry::NUM_X; x++){
                    std::cout << entry.Q[x + y * QEntry::NUM_X] << "  ";
                }
                std::cout << std::endl;
            }
            std::cout << std::endl << std::endl;
        }
    }



    void RLPTIntegrator::render(const Scene& scene, const CameraObject& camera, FilmObject& film) {

        int numBlocks, numThreads;
        setNumBlocksThreads(QTable.N, numBlocks, numThreads);
        initialiseQTable<<<numBlocks,numThreads>>>(QTable.getCopyForKernel());

        int round = 0;

        while(!isFinished( scene, camera,  film)){
            GpuArray<CameraSample> allSamples = sampler->genAllCameraSamples(camera, film);

            SceneHandle sceneHandle = scene.getDeviceHandle();
    
            SamplerObject& samplerObject = *sampler;
    
    
            int samplesCount = (int)allSamples.N;
            setNumBlocksThreads(samplesCount, numBlocks, numThreads);

            sampler->prepare(samplesCount);

            //debugTestEntrySampling << <1, 1 >> > (samplerObject);
            //SIGNAL_ERROR("done testing\n");
    
            GpuArray<Spectrum> result(samplesCount);

            TaskQueue<RayTask> rayQueue0(samplesCount);
            TaskQueue<RayTask> rayQueue1(samplesCount);
    
            TaskQueue<RayTask>* thisRoundRayQueue = &rayQueue0;
            TaskQueue<RayTask>* nextRoundRayQueue = &rayQueue1;

            TaskQueue<LightingTask> lightingQueue(samplesCount);
            TaskQueue<LightingTask> lightingQueueCopy(samplesCount);

            TaskQueue<MaterialEvalTask> materialEvalQueue(samplesCount);

            int QCellsCount = QTable.N * QEntry::NUM_XY;

            std::cout << numBlocks << "   " << numThreads << std::endl;
            genInitialRays << <numBlocks, numThreads >> > (allSamples.data,samplesCount,camera,result.data,thisRoundRayQueue->getCopyForKernel(), samplerObject.getCopyForKernel());
            CHECK_CUDA_ERROR("gen initial rays");

            int depth = 0;

            while (thisRoundRayQueue->count() > 0 && depth <= maxDepth) {
                std::cout << "\ndoing depth " << depth << std::endl;

                //if(depth>=2)  debugPrintQTable(QTable);

                thisRoundRayQueue->setNumBlocksThreads(numBlocks, numThreads);
                std::string intersectSceneEvent = std::string("intersectScene ") + std::to_string(round)+" " + std::to_string(depth);
                Timer::getInstance().timedRun(intersectSceneEvent, [&](){
                    intersectScene << <numBlocks, numThreads >> >
                        (sceneHandle, samplerObject.getCopyForKernel(), lightingQueue.getCopyForKernel(), thisRoundRayQueue->getCopyForKernel(), nextRoundRayQueue->getCopyForKernel(), depth);
                });
                

                thisRoundRayQueue->clear();


                std::string sortEvent = std::string("sort queue ") + std::to_string(round) + " " + std::to_string(depth);
                Timer::getInstance().timedRun(sortEvent, [&](){
                    sortLightingQueue(lightingQueue, lightingQueueCopy, *nextRoundRayQueue,*thisRoundRayQueue,samplerObject,scene.sceneBounds);
                });

                if (lightingQueue.count() > 0) {
                    setNumBlocksThreads(QCellsCount, numBlocks, numThreads);
                    prepareForUpdateQ << <numBlocks, numThreads >> > (QTable.getCopyForKernel());
                    CHECK_CUDA_ERROR("prepare update q");


                    sampler->syncDimension();
                    lightingQueue.setNumBlocksThreads(numBlocks, numThreads);
                    std::string lightingEvent = std::string("lighting ") + std::to_string(round) + " " + std::to_string(depth);
                    Timer::getInstance().timedRun(lightingEvent, [&]() {
                        computeLighting << <numBlocks, numThreads >> > (sceneHandle, samplerObject.getCopyForKernel(), lightingQueue.getCopyForKernel(), materialEvalQueue.getCopyForKernel(), depth,scene.sceneBounds,QTable.getCopyForKernel());
                    });

                    

                    if (materialEvalQueue.count() > 0) {
                        materialEvalQueue.setNumBlocksThreads(numBlocks, numThreads);
                        std::string materialEvent = std::string("material ") + std::to_string(round) + " " + std::to_string(depth);
                        Timer::getInstance().timedRun(materialEvent, [&]() {
                            evalMaterial << <numBlocks, numThreads >> > (sceneHandle,materialEvalQueue.getCopyForKernel(),scene.sceneBounds,QTable.getCopyForKernel());
                        });
                    }


                    setNumBlocksThreads(QCellsCount,numBlocks,numThreads);
                    finishUpdateQ<<<numBlocks,numThreads>>>(QTable.getCopyForKernel());
                    CHECK_CUDA_ERROR("finish update q");

                    sampler->syncDimension();
                    lightingQueue.setNumBlocksThreads(numBlocks, numThreads);
                    std::string genNextRayEvent = std::string("genNext ") + std::to_string(round) + " " + std::to_string(depth);
                    Timer::getInstance().timedRun(genNextRayEvent, [&]() {
                        genNextRay << <numBlocks, numThreads >> > (sceneHandle, samplerObject.getCopyForKernel(), lightingQueue.getCopyForKernel(), nextRoundRayQueue->getCopyForKernel(), depth,scene.sceneBounds,QTable.getCopyForKernel());
                    });
                }

                sampler->syncDimension();

                lightingQueue.clear();
                materialEvalQueue.clear();

                ++depth;
                std::swap(thisRoundRayQueue, nextRoundRayQueue);

            }

            setNumBlocksThreads(samplesCount, numBlocks, numThreads);

            addSamplesToFilm << <numBlocks, numThreads >> > (film.getCopyForKernel(), result.data, allSamples.data, samplesCount);
            CHECK_CUDA_ERROR("add sample to film");

            ++round;


        }
        //debugPrintQTable(QTable);

    }

}
